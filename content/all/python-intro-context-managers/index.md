+++
categories = ["nuggets", ]
author = "Raul Morales Delgado"
title = "An Intro to Python's Context Managers with contextlib"
description = "Because managing resources with Python is better with context managers — and context managers are better with `contextlib`. This article is a gentle introduction to context managers using `contextmanager` from `contextlib`."
date = "2019-08-25"
toc = true
tags = ["python", "contextlib", ]
+++

In Python, Context Managers allow to efficiently manage resources by letting users set rules on what to do with those resources when working with them. Creating Context Managers from scratch, though, might get a little [tedious](https://docs.python.org/3.8/library/stdtypes.html#context-manager-types) since `__enter__()` and `__exit__()` methods have to be defined, as well as the ancillary code to deal with exceptions. 

To simplify this, out-of-the-box context managers can be created using [`contextlib`](https://docs.python.org/3/library/contextlib.html)'s `contextmanager` module — it allows to write a context manager in just a few lines.

>**Note:** This post is not a tutorial or in-depth explanation of context managers. It is merely an introduction on how to simplify their creation using Python's built-in `contextlib`.


## 1. Creating a Context Manager with "contextlib"
The first step is to import the `contextmanager` module from `contextlib`. This module is a decorator used to define factory functions for with-statement context managers.[^1]

[^1]: https://docs.python.org/3/library/contextlib.html#contextlib.contextmanager

```python
from contextlib import contextmanager
```

The structure to create a context manager is fairly simple. See the following example right from the [Python docs](https://docs.python.org/3/library/contextlib.html#contextlib.contextmanager):
```python
@contextmanager
def managed_resource(*args, **kwds):
    # Code to acquire resource, e.g.:
    resource = acquire_resource(*args, **kwds)
    try:
        yield resource
    finally:
        # Code to release resource, e.g.:
        release_resource(resource)
```

After declaring the decorator, `@contextmanager`, a regular function with a `yield` clause (instead of `return`) is defined. This context manager can be called using a `with` statement:
```python
with managed_resource(arg1, ..., kwarg1 = var1, ...) as resource:
    do_thing_with_resource(resource)
```

The block below the `with` clause is called the *suite*, or (colloquially) *with-statement body*. When executed, everything before `yield` will be run *before* the with-statement body, and everything after `yield` will be run *after* the with-statement body. Whatever object is generated by `yield` (yes, this function returns a one-value [generator-iterator](https://docs.python.org/3/glossary.html#term-generator-iterator)) will be accessible in the scope from which the `with` statement was executed. Likewise, anything declared inside the with-statement body will also be accessible in the same scope.

Let's break this down with some code.


## 2. A Very Simple Context Manager
First, let's create a very simple context manager — one that only appends one tag before and one tag after a yielded object using `print`.

```python
@contextmanager
def tagger_1(text):
    print(f"Top tagger_1: {text}")
    yield
    print(f"Bottom tagger_1: {text}")
```

Below, the context manager `tagger_1` is used in a `with` statement, and a `print` function will be run inside the with-statement body:

```python
with tagger_1("hello"):
    print("foo")
```
```text
Top tagger_1: hello
foo
Bottom tagger_1: hello
```

As seen above, the tags are printed before and after the `print` function, which is what was expected.


## 3. The "as" Clause
What happens, though, when an `as` clause is added to a `with` clause? The `as` keyword, in this context, is meant to retrieve whatever object — or objects — are "yielded" by the context manager and assign them to the target (e.g. `resource`) that accompanies it in the `as` clause.

In the context manager (i.e. the generator), `yield` is used to indicate when the generated object will be passed to the caller — the `with` statement. After being assigned to the target using `as`, the with-statement body is executed. Once the with-statement body is executed, the block after `yield` is executed. Note that if no object is stated in the `yield` clause, then `None` will be yielded. This is shown below:


```python
with tagger_1('hello again!') as mytag:
    print(mytag)
```
```text
Top tagger_1: hello again!
None
Bottom tagger_1: hello again!
```


Let's explore a little further what `yield` does. Below is a second example of `tagger`, but now with an object being yielded:


```python
@contextmanager
def tagger_2(text):
    print(f"Top tagger_2: {text}")
    yield text + ' — I am being yielded!'
    print(f"Bottom tagger_2: {text}")
```

If `tagger_2` is run without an `as` clause, then the "yielded" object will be generated but not assigned:


```python
with tagger_2("hey!"):
    print("foo")
```
```text
Top tagger_2: hey!
foo
Bottom tagger_2: hey!
```


## 4. Generating Several Object
How do we know that anything is being generated at all, then? Let's modify again the `tagger` example again to yield several objects, including a `print` function:


```python
@contextmanager
def tagger_3(text):
    print(f"Top tagger_3: {text}")
    yield 123, "I am a string", print("I have been generated")
    print(f"Bottom tagger_3: {text}")

with tagger_3("hello") as my_target:
    print("foo")
    print(my_target)
```

```text
Top tagger_3: hello
I have been generated
foo
(123, 'I am a string', None)
Bottom tagger_3: hello
```


When the `with` statement is run, the following can be observed:
1. The top tag appears first
2. The objects from the context manager's `yield` clause are evaluated and generated
3. The with-statement body is run *after* the `yield` clause is executed
4. The `my_target` variable holds a tuple with all the elements that were generated by the context manager
4. The bottom tag appears last.

Also, note that the third item in `my_target` is `None`, which is what `print` returns after being successfully executed.


## 5. Variable Scope
Back to our previous example, if an `as` clause is added to the `with` statement and the target variable is not called in the with-statement body, the yielded object(s) will still remain stored in the variable and will be accessible when called from the same scope of the `with` statement was — e.g. for all previous examples, the global scope. Also, everything declared in the with-statement body will be accessible from that same scope.

Let's try this out. If the `with` statement is run from the global scope, then its variables will be accessible when called from the global scope:

```python
with tagger_2("hey!") as my_target2:
    print("foo")
    var1 = "I am var1"

print(my_target2)
print(var1)
```
```text
Top tagger_2: hey!
foo
Bottom tagger_2: hey!
HEY! — I am being yielded!
I am var1
```

If, however, the same `with` statement is now run from a function, then its variables will only be accessible from the scope of that function:

```python
def my_func(text):
    with tagger_2(text) as local_target2:
        print("foo")
        local_var1 = "I am var1"

    print(local_target2)
    print(local_var1)

my_func('hey')
```
```text
Top tagger_2: hey
foo
Bottom tagger_2: hey
HEY — I am being yielded!
I am var1
```

If those same variables are called from the global scope, then a `NameError` exception will appear stating that those variables are not defined — they do not exist in this scope.

```python
print(local_target2)
print(local_var1)
```
```text
---------------------------------------------------------------------------

NameError                                 Traceback (most recent call last)

<ipython-input-24-2698026fdf53> in <module>
----> 1 print(local_target2)
        2 print(local_var1)


NameError: name 'local_target2' is not defined
```

## 6. Acknowledgements

* <https://realpython.com/introduction-to-python-generators/>
* <https://alysivji.github.io/managing-resources-with-context-managers-pythonic.html>
* <https://jeffknupp.com/blog/2016/03/07/python-with-context-managers/>
